<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Car Scene - Mobile Controls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Prevent scrollbars */
            background-color: #a0d7e6;
            /* Light sky blue background */
            font-family: 'Press Start 2P', cursive, sans-serif;
            /* A retro arcade font for style */
            /* NUCLEAR OPTION: Maximum webview override */
            overscroll-behavior: none !important;
            touch-action: none !important;
            -ms-touch-action: none !important;
            -webkit-touch-action: none !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
            -moz-user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-tap-highlight-color: transparent !important;
            /* Prevent ALL native mobile gestures */
        }

        canvas {
            display: block;
            /* Remove annoying space below canvas */
            /* CRITICAL WEBVIEW FIX: Prevent canvas touch interference */
            touch-action: none !important;
            -ms-touch-action: none !important;
            -webkit-touch-action: none !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            /* Additional mobile gesture prevention */
            -webkit-touch-callout: none !important;
            -webkit-tap-highlight-color: transparent !important;
            pointer-events: auto !important;
        }

        #container {
            /* NUCLEAR OPTION: Maximum container touch prevention */
            touch-action: none !important;
            -ms-touch-action: none !important;
            -webkit-touch-action: none !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
            -moz-user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-tap-highlight-color: transparent !important;
            pointer-events: auto !important;
            /* Force container to be completely touch-neutral */
        }

        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            /* For progress text */
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            gap: 15px;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
            /* Disable interaction after fading */
        }

        #loading-text {
            font-size: 1em;
        }

        #loading-progress {
            font-size: 0.8em;
        }

        /* --- UI Elements --- */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            /* White text */
            text-shadow: 1px 1px 3px black;
            /* Black shadow for readability */
            z-index: 50;
            font-size: 1.5em;
            /* Slightly larger font */
            pointer-events: none;
            /* Let clicks pass through */
        }

        /* --- Compact High-Contrast UI Elements --- */
        .ui-element {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000000;
            border: 2px solid #ffffff;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 6px;
            box-shadow: 
                0 3px 0 #333333,
                0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 150;
            position: relative;
        }

        .ui-label {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-size: 0.5em;
            color: #ffffff;
            margin-bottom: 3px;
            letter-spacing: 1px;
            font-weight: bold;
            line-height: 1;
        }

        #score-value {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-size: 1em;
            color: #ffff00;
            font-weight: bold;
            letter-spacing: 1px;
            min-width: 50px;
            text-align: center;
            text-shadow: 1px 1px 0 #000000;
            line-height: 1;
        }

        #timer-value {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-size: 1em;
            color: #ffffff;
            font-weight: bold;
            letter-spacing: 1px;
            min-width: 50px;
            text-align: center;
            text-shadow: 1px 1px 0 #000000;
            line-height: 1;
        }

        #timer-value.warning {
            color: #ff0040;
            animation: pulse 0.5s infinite;
        }

        /* Legacy selectors for compatibility */
        #score, #timer {
            display: none; /* Hide old elements */
        }

        #timer.warning {
            color: #ff0040; /* Bright red for warning */
            text-shadow: 0 0 15px #ff0040, 2px 2px 6px rgba(0, 0, 0, 0.9); /* Enhanced glow for warning */
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Enhanced blur overlay for game over */
        #game-over-blur {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(12px) brightness(0.3) contrast(1.2);
            -webkit-backdrop-filter: blur(12px) brightness(0.3) contrast(1.2);
            background: radial-gradient(circle at center, rgba(255, 0, 64, 0.1), rgba(0, 0, 0, 0.6));
            display: none;
            z-index: 100;
            pointer-events: none;
            animation: blurFadeIn 0.5s ease-out;
        }

        @keyframes blurFadeIn {
            0% { 
                backdrop-filter: blur(0px) brightness(1) contrast(1);
                -webkit-backdrop-filter: blur(0px) brightness(1) contrast(1);
                opacity: 0;
            }
            100% { 
                backdrop-filter: blur(12px) brightness(0.3) contrast(1.2);
                -webkit-backdrop-filter: blur(12px) brightness(0.3) contrast(1.2);
                opacity: 1;
            }
        }

        #game-over-message {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444; /* Bright red matching reference image */
            font-family: 'Courier New', monospace;
            font-size: 3em; /* Larger for impact */
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 25px #ff4444, 4px 4px 12px rgba(0, 0, 0, 0.95); /* Strong glow and shadow */
            display: none;
            z-index: 101;
            pointer-events: none;
            white-space: nowrap;
            letter-spacing: 3px;
            /* Add subtle animation */
            animation: gameOverGlow 2s ease-in-out infinite alternate;
        }

        #restart-message {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 15px #00ffff, 2px 2px 6px rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 101;
            cursor: pointer;
            pointer-events: auto;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        #restart-message:hover {
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff, 2px 2px 8px rgba(0, 0, 0, 0.9);
            transform: translate(-50%, -50%) scale(1.1);
        }

        @keyframes gameOverGlow {
            0% { text-shadow: 0 0 25px #ff4444, 4px 4px 12px rgba(0, 0, 0, 0.95); }
            100% { text-shadow: 0 0 35px #ff4444, 4px 4px 12px rgba(0, 0, 0, 0.95); }
        }


        /* Old game over elements - now unused */
        #game-over {
            display: none !important;
        }

        #restart-button {
            display: none !important;
        }


        /* --- Modern Game Control Pad --- */
        .game-control-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 60;
            /* CRITICAL WEBVIEW OVERRIDE */
            touch-action: none !important;
            -webkit-touch-action: none !important;
            -ms-touch-action: none !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            pointer-events: auto !important;
        }

        .game-control-pad {
            width: 90px;
            height: 70px;
            background: #000000;
            border: 2px solid #ffffff;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            /* ABSOLUTE WEBVIEW OVERRIDE */
            touch-action: none !important;
            -webkit-touch-action: none !important;
            -ms-touch-action: none !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            pointer-events: auto !important;
            /* Solid, professional transitions */
            transition: all 0.1s ease;
            box-shadow: 
                0 4px 0 #333333,
                0 6px 8px rgba(0, 0, 0, 0.3);
        }

        .control-icon {
            font-size: 2.2em;
            color: #ffffff;
            text-shadow: none;
            margin-bottom: 1px;
            font-weight: 900;
            filter: none;
            line-height: 1;
        }

        .control-label {
            font-size: 0.6em;
            color: #ffffff;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: none;
            line-height: 1;
        }

        /* Active/Pressed State */
        .game-control-pad:active,
        .game-control-pad.pressed {
            background: #ffffff !important;
            border-color: #000000 !important;
            transform: translateY(4px);
            box-shadow: 
                0 0 0 #333333,
                0 2px 6px rgba(0, 0, 0, 0.5);
        }

        .game-control-pad.pressed .control-icon {
            color: #000000 !important;
        }

        .game-control-pad.pressed .control-label {
            color: #000000 !important;
        }

        /* Hover effect for desktop */
        .game-control-pad:hover {
            background: #222222;
            border-color: #00ffff;
        }

        /* Hide controls when game over */
        .game-control-container.hidden {
            display: none !important;
        }

        /* Responsive design */
        @media (max-width: 480px) {
            .game-control-pad {
                width: 80px;
                height: 60px;
            }
            .control-icon {
                font-size: 1.8em;
            }
            .control-label {
                font-size: 0.5em;
            }
            .ui-element {
                padding: 6px 10px;
                margin-bottom: 4px;
            }
            #score-value, #timer-value {
                font-size: 0.9em;
            }
        }
        /* --- End Modern Game Control Pad --- */

        /* Import Google Font for UI */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>

<body>
    <div id="loading-screen">
        <div id="loading-text">Loading Game...</div>
        <div id="loading-progress">0%</div>
    </div>
    <div id="container"></div>

    <div id="ui-container">
        <div id="score-display" class="ui-element">
            <span class="ui-label">SCORE</span>
            <span id="score-value">0</span>
        </div>
        <div id="timer-display" class="ui-element">
            <span class="ui-label">TIME</span>
            <span id="timer-value">1:00</span>
        </div>
    </div>
    <div id="game-over">
        GAME OVER!
        <button id="restart-button">Restart</button>
    </div>

    <!-- New game over UI -->
    <div id="game-over-blur"></div>
    <div id="game-over-message">GAME OVER</div>
    <div id="restart-message">TAP TO RESTART</div>

    <!-- Modern Game Control Pad -->
    <div class="game-control-container">
        <button id="control-left" class="game-control-pad left-control">
            <div class="control-icon">◀</div>
            <div class="control-label">LEFT</div>
        </button>
        <button id="control-right" class="game-control-pad right-control">
            <div class="control-icon">▶</div>
            <div class="control-label">RIGHT</div>
        </button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js'; // For HDRI

        // Modern control elements
        const restartMessage = document.getElementById('restart-message');
        const controlContainer = document.querySelector('.game-control-container');
        const leftControlButton = document.getElementById('control-left');
        const rightControlButton = document.getElementById('control-right');
        
        // ROBUST VELOCITY-BASED SYSTEM: Space Invaders movement model
        const CAR_SPEED = 0.5; // Fixed car speed constant
        let carVelocityX = 0; // Global velocity variable - initialized to 0
        let gameStarted = true; // Start immediately without permission

        let scene, camera, renderer, carModel, enemyCar;
        let ambientLight, directionalLight;
        let road, roadLines = [], kerbs = [];
        let buildings = [], streetLights = [], trafficLights = [];
        const roadWidth = 10;
        const roadLength = 200; // Visible length of the road
        const sceneryRecycleDistance = roadLength / 2; // Distance to recycle scenery elements
        const buildingSpacing = 15;
        const lightSpacing = 30;
        const numBuildings = Math.floor(roadLength * 1.5 / buildingSpacing); // Spawn more buildings to cover recycle distance
        const numLights = Math.floor(roadLength * 1.5 / lightSpacing);

        let driveSpeed = 0.5; // Scenery scroll speed (player's effective forward speed) - now dynamic
        const baseDriveSpeed = 0.5; // Base speed for difficulty scaling
        const enemyCarSpeed = 0.6; // Enemy moves faster relative to scenery scroll

        const kerbHeight = 0.2;
        const kerbWidth = 0.3;

        // --- Game State ---
        let carBaseY = 0; // Will be calculated based on car model bounding box
        let score = 0;
        let isGameOver = false;
        let gameTime = 0; // Track game time for progressive difficulty
        const speedIncreaseInterval = 30; // Increase speed every 30 seconds
        const speedIncreaseAmount = 0.05; // Amount to increase speed
        let lastSpeedIncrease = 0;
        
        // --- Timer Variables ---
        let countdownTime = 60; // 60 seconds (1 minute)
        let lastFrameTime = 0; // Track time for countdown
        let accumulatedTime = 0; // Accumulate delta time
        // --- End Game State ---

        // --- Points ---
        const points = [];
        const numPoints = 20; // Increased from 15 for more challenge
        const pointValue = 10;
        let pointGeometry, pointMaterial;
        const pointRadius = 0.3;
        // --- End Points ---

        // --- Obstacles (Additional Enemy Cars) ---
        const obstacles = [];
        const numObstacles = 5; // Multiple obstacles to increase difficulty
        // --- End Obstacles ---

        // --- UI Elements References ---
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgress = document.getElementById('loading-progress');
        const scoreElement = document.getElementById('score-value');
        const timerElement = document.getElementById('timer-value');
        const gameOverElement = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        // --- End UI Refs ---

        // --- Bounding Boxes (for collision detection) ---
        let playerBox = new THREE.Box3();
        let enemyBox = new THREE.Box3();
        let pointBox = new THREE.Box3();
        // Debug helpers (uncomment to visualize hitboxes)
        // let playerBoxHelper, enemyBoxHelper;
        // --- End Bounding Boxes ---

        const loadingManager = new THREE.LoadingManager();

        // Loading Manager Callbacks
        loadingManager.onLoad = () => {
            console.log("All resources loaded!");
            loadingScreen.classList.add('hidden');
            setTimeout(() => {
                if (loadingScreen) loadingScreen.style.display = 'none';
                // Initialize timer display
                updateTimerDisplay();
                console.log("Starting game with countdown:", countdownTime);
                // Start game loop after loading screen fades
                if (!isGameOver) {
                    requestAnimationFrame(animate); // Use requestAnimationFrame to get proper timestamp
                }
            }, 600);
        };
        loadingManager.onError = (url) => {
            console.error(`There was an error loading ${url}`);
            loadingScreen.textContent = `Error loading: ${url}. Check console.`;
            loadingScreen.classList.remove('hidden');
            loadingScreen.style.opacity = 1;
        };
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            const progress = Math.round((itemsLoaded / itemsTotal) * 100);
            loadingProgress.textContent = `${progress}%`;
        };


        init(); // Initialize the scene and elements
        setupControls(); // Set up both keyboard and touch controls
        
        
        // NUCLEAR OPTION: Ultimate document-level touch override
        document.addEventListener('touchstart', (e) => {
            // Allow only specific interactive elements
            const target = e.target;
            const allowedElements = ['control-left', 'control-right', 'restart-message'];
            const isAllowed = allowedElements.some(id => target.id === id || target.closest(`#${id}`));
            
            if (!isAllowed) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                console.log('Document touchstart blocked for:', target.tagName);
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('touchmove', (e) => {
            e.preventDefault(); // ALWAYS prevent scrolling
            e.stopPropagation();
            e.stopImmediatePropagation();
        }, { passive: false, capture: true });
        
        document.addEventListener('touchend', (e) => {
            // Block touchend on non-interactive elements
            const target = e.target;
            const allowedElements = ['control-left', 'control-right', 'restart-message'];
            const isAllowed = allowedElements.some(id => target.id === id || target.closest(`#${id}`));
            
            if (!isAllowed) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, { passive: false, capture: true });
        
        // NUCLEAR OPTION: Block all pointer events on document
        document.addEventListener('pointerdown', (e) => {
            const target = e.target;
            const allowedElements = ['control-left', 'control-right', 'restart-message'];
            const isAllowed = allowedElements.some(id => target.id === id || target.closest(`#${id}`));
            
            if (!isAllowed) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('pointermove', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
        }, { passive: false, capture: true });
        
        document.addEventListener('pointerup', (e) => {
            const target = e.target;
            const allowedElements = ['control-left', 'control-right', 'restart-message'];
            const isAllowed = allowedElements.some(id => target.id === id || target.closest(`#${id}`));
            
            if (!isAllowed) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, { passive: false, capture: true });
        
        console.log('NUCLEAR OPTION: Complete document gesture isolation applied');
        
        // animate() will be called by loadingManager.onLoad after everything is ready.

        function init() {
            // --- Basic Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6); // Default background before HDRI
            scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9); // Fog for depth

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial camera position (will be adjusted after car model loads)
            camera.position.set(0, 3, -7);

            // PERFORMANCE OPTIMIZED: Prioritize speed over quality for webview
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,           // Disable antialiasing for better performance
                powerPreference: "high-performance",
                precision: "mediump"        // Use medium precision for better performance
            });
            
            // Reduce render resolution for better performance on high-DPI displays
            const pixelRatio = Math.min(window.devicePixelRatio, 2); // Cap at 2x
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Optimize shadow settings for performance
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap; // Fastest shadow type
            renderer.shadowMap.autoUpdate = false; // Manual shadow updates for better performance
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // For PBR realism
            renderer.toneMappingExposure = 1.2; // Adjust exposure for HDRI
            document.getElementById('container').appendChild(renderer.domElement);
            
            // NUCLEAR OPTION: Maximum canvas touch override
            renderer.domElement.style.touchAction = 'none';
            renderer.domElement.style.webkitTouchAction = 'none';
            renderer.domElement.style.msTouchAction = 'none';
            renderer.domElement.style.userSelect = 'none';
            renderer.domElement.style.webkitUserSelect = 'none';
            renderer.domElement.style.msUserSelect = 'none';
            renderer.domElement.style.mozUserSelect = 'none';
            renderer.domElement.style.webkitTouchCallout = 'none';
            renderer.domElement.style.webkitTapHighlightColor = 'transparent';
            renderer.domElement.style.pointerEvents = 'auto';
            
            // NUCLEAR OPTION: Aggressive canvas event blocking with capture
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                console.log('Canvas touchstart blocked');
            }, { passive: false, capture: true });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, { passive: false, capture: true });
            
            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, { passive: false, capture: true });
            
            // Additional pointer events blocking
            renderer.domElement.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, { passive: false, capture: true });
            
            renderer.domElement.addEventListener('pointermove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, { passive: false, capture: true });
            
            renderer.domElement.addEventListener('pointerup', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, { passive: false, capture: true });
            
            console.log('NUCLEAR OPTION: Canvas completely isolated from webview gestures');

            // --- Lights ---
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Softer ambient light
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Main light (sun)
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            scene.add(directionalLight.target); // Target for directional light

            // --- HDRI Environment Map ---
            // Using a common HDRI from Three.js examples (adjust path/name if you have your own)
            const hdrPath = 'https://threejs.org/examples/textures/equirectangular/';
            const hdrName = 'venice_sunset_1k.hdr'; // Or 'royal_esplanade_1k.hdr', 'memorial_park_1k.hdr'

            new RGBELoader(loadingManager) // Use loadingManager
                .setPath(hdrPath)
                .load(hdrName, function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; // Apply to reflective materials
                    scene.background = texture; // Use as background
                }, undefined, (error) => {
                    console.error('Error loading HDRI:', error);
                    scene.background = new THREE.Color(0xa0d7e6); // Fallback to solid color
                });


            // --- Ground, Road, Lines, Kerbs ---
            const groundGeo = new THREE.PlaneGeometry(roadWidth * 5, roadLength * 1.5); // Wider ground
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, side: THREE.DoubleSide, roughness: 0.9, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength * 1.5); // Longer road for smooth scrolling
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 }); // Darker, slightly reflective asphalt
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.0;
            road.receiveShadow = true;
            scene.add(road);

            const lineLength = 4;
            const lineGap = 4;
            const numLines = Math.floor(roadLength * 1.5 / (lineLength + lineGap)); // More lines
            const lineGeo = new THREE.PlaneGeometry(0.3, lineLength);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0.2, metalness: 0.0 });
            for (let i = 0; i < numLines; i++) {
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.y = 0.005; // Slightly above road to prevent Z-fighting
                line.position.z = (roadLength * 1.5 / 2) - (lineLength / 2) - i * (lineLength + lineGap);
                line.receiveShadow = true;
                roadLines.push(line);
                scene.add(line);
            }

            function createKerbTexture() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 16;
                const stripeWidth = 8;
                const colors = ['#ff0000', '#ffffff'];
                for (let i = 0; i < canvas.width / stripeWidth; i++) {
                    ctx.fillStyle = colors[i % 2];
                    ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height);
                }
                return new THREE.CanvasTexture(canvas);
            }
            const kerbTexture = createKerbTexture();
            kerbTexture.wrapS = THREE.RepeatWrapping;
            kerbTexture.wrapT = THREE.ClampToEdgeWrapping;
            kerbTexture.repeat.set(roadLength * 1.5 / 4, 1); // Repeat over longer road
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, kerbHeight, roadLength * 1.5);
            const kerbMat = new THREE.MeshStandardMaterial({ map: kerbTexture, roughness: 0.7, metalness: 0.1 });

            const kerbLeft = new THREE.Mesh(kerbGeo, kerbMat);
            kerbLeft.position.set(-(roadWidth / 2) - (kerbWidth / 2), kerbHeight / 2, 0);
            kerbLeft.castShadow = true;
            kerbLeft.receiveShadow = true;
            scene.add(kerbLeft);
            kerbs.push(kerbLeft);

            const kerbRight = new THREE.Mesh(kerbGeo, kerbMat);
            kerbRight.position.set((roadWidth / 2) + (kerbWidth / 2), kerbHeight / 2, 0);
            kerbRight.castShadow = true;
            kerbRight.receiveShadow = true;
            scene.add(kerbRight);
            kerbs.push(kerbRight);


            // --- Buildings, Street Lights, Traffic Lights ---
            function createBuilding() {
                const height = Math.random() * 30 + 10;
                const width = Math.random() * 8 + 4;
                const depth = Math.random() * 8 + 4;
                const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                const buildingMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2), // Grayscale-ish colors
                    roughness: 0.8,
                    metalness: 0.1
                });
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.y = height / 2;
                building.castShadow = true;
                building.receiveShadow = true;
                return building;
            }
            for (let i = 0; i < numBuildings; i++) {
                const buildingLeft = createBuilding();
                const buildingRight = createBuilding();
                const zPos = (roadLength * 1.5 / 2) - (buildingSpacing / 2) - i * buildingSpacing;
                const xOffsetLeft = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingLeft.geometry.parameters.width / 2;
                const xOffsetRight = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingRight.geometry.parameters.width / 2;
                buildingLeft.position.set(-xOffsetLeft, buildingLeft.position.y, zPos);
                buildingRight.position.set(xOffsetRight, buildingRight.position.y, zPos);
                buildings.push(buildingLeft, buildingRight);
                scene.add(buildingLeft);
                scene.add(buildingRight);
            }

            function createStreetLight() {
                const group = new THREE.Group();
                const poleHeight = 6;
                const poleRadius = 0.1;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.4 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.castShadow = true;
                pole.position.y = poleHeight / 2;
                group.add(pole);

                const armLength = 1.5; // Longer arm
                const armGeo = new THREE.BoxGeometry(armLength, poleRadius * 1.5, poleRadius * 1.5);
                const arm = new THREE.Mesh(armGeo, poleMat);
                arm.position.set(0, poleHeight - poleRadius * 2, 0); // Position arm correctly
                group.add(arm);

                const lightFixtureGeo = new THREE.SphereGeometry(poleRadius * 2, 16, 8);
                const lightFixtureMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffff00, emissiveIntensity: 0.5 });
                const lightFixture = new THREE.Mesh(lightFixtureGeo, lightFixtureMat);
                lightFixture.position.set(0, poleHeight - poleRadius * 2, 0); // Position fixture correctly
                group.add(lightFixture);

                group.userData.armLength = armLength; // Store for positioning later
                return group;
            }
            for (let i = 0; i < numLights; i++) {
                const lightLeft = createStreetLight();
                const lightRight = createStreetLight();
                const zPos = (roadLength * 1.5 / 2) - (lightSpacing / 2) - i * lightSpacing;
                const xPos = roadWidth / 2 + kerbWidth + 0.8;

                lightLeft.position.set(-xPos, 0, zPos);
                lightLeft.rotation.y = Math.PI / 2; // Rotate to face road
                lightLeft.children[1].position.x = -lightLeft.userData.armLength / 2; // Arm extends inwards
                lightLeft.children[2].position.x = -lightLeft.userData.armLength; // Light at end of arm
                streetLights.push(lightLeft);
                scene.add(lightLeft);

                lightRight.position.set(xPos, 0, zPos);
                lightRight.rotation.y = -Math.PI / 2; // Rotate to face road
                lightRight.children[1].position.x = -lightRight.userData.armLength / 2; // Arm extends inwards
                lightRight.children[2].position.x = -lightRight.userData.armLength; // Light at end of arm
                streetLights.push(lightRight);
                scene.add(lightRight);
            }

            function createTrafficLight() {
                const group = new THREE.Group();
                const poleHeight = 5;
                const poleRadius = 0.15;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.5 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.y = poleHeight / 2;
                pole.castShadow = true;
                group.add(pole);

                const housingWidth = 0.5;
                const housingHeight = 1.2;
                const housingDepth = 0.3;
                const housingGeo = new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth);
                const housingMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const housing = new THREE.Mesh(housingGeo, housingMat);
                housing.position.y = poleHeight - housingHeight / 2;
                housing.castShadow = true;
                group.add(housing);

                const lightRadius = housingWidth * 0.25;
                const lightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);
                const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 1 });
                const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 1 });
                const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 1 });

                const redLight = new THREE.Mesh(lightGeo, redMat); redLight.position.set(0, housingHeight * 0.3, housingDepth / 2 + 0.01); housing.add(redLight);
                const yellowLight = new THREE.Mesh(lightGeo, yellowMat); yellowLight.position.set(0, 0, housingDepth / 2 + 0.01); housing.add(yellowLight);
                const greenLight = new THREE.Mesh(lightGeo, greenMat); greenLight.position.set(0, -housingHeight * 0.3, housingDepth / 2 + 0.01); housing.add(greenLight);

                return group;
            }
            // Only one traffic light in view for now, more can be added later as a loop
            const trafficLightLeft = createTrafficLight();
            const trafficLightRight = createTrafficLight();
            const trafficLightZ = roadLength * 0.4;
            const trafficLightX = roadWidth / 2 + kerbWidth + 0.5;
            trafficLightLeft.position.set(-trafficLightX, 0, trafficLightZ);
            trafficLightLeft.rotation.y = Math.PI / 2;
            trafficLightRight.position.set(trafficLightX, 0, trafficLightZ);
            trafficLightRight.rotation.y = -Math.PI / 2;
            trafficLights.push(trafficLightLeft, trafficLightRight);
            scene.add(trafficLightLeft);
            scene.add(trafficLightRight);


            // --- Points Setup ---
            pointGeometry = new THREE.SphereGeometry(pointRadius, 16, 16); // More segments for smoother look
            pointMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 0.8, metalness: 0.9, roughness: 0.1 });
            for (let i = 0; i < numPoints; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.castShadow = true;
                point.receiveShadow = true;
                resetPointPosition(point, true); // initial positions spread out
                points.push(point);
                scene.add(point);
            }

            // --- Car Model Loading ---
            const loader = new GLTFLoader(loadingManager);
            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            loader.setDRACOLoader(dracoLoader);
            // Official Ferrari GLB URL
            const carUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';

            loader.load(carUrl, (gltf) => {
                carModel = gltf.scene;
                carModel.scale.set(0.8, 0.8, 0.8); // Scale down for scene
                const box = new THREE.Box3().setFromObject(carModel);
                carBaseY = -box.min.y + 0.01; // Adjust Y to sit on road
                carModel.position.set(0, carBaseY, 0);
                carModel.rotation.y = Math.PI; // Face forward

                carModel.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // For PBR materials like in Ferrari model, environment map is key
                        // Materials are generally MeshPhysicalMaterial
                    }
                });
                scene.add(carModel);

                // --- Enemy Car Setup (Clone Player Car) ---
                enemyCar = carModel.clone();
                enemyCar.traverse((node) => {
                    if (node.isMesh) {
                        // Create a distinct material for the enemy car (e.g., metallic blue)
                        const originalMaterial = node.material;
                        const enemyMaterial = originalMaterial.clone();
                        enemyMaterial.color.setHex(0x0000ff); // Set to blue
                        enemyMaterial.metalness = 0.9;
                        enemyMaterial.roughness = 0.2;
                        node.material = enemyMaterial;
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7); // Spawn further down the road
                enemyCar.rotation.y = Math.PI; // Face forward initially, will be reversed for oncoming
                scene.add(enemyCar);
                console.log("Enemy car added and colored blue");

                // --- Create Additional Obstacles ---
                for (let i = 0; i < numObstacles; i++) {
                    const obstacle = carModel.clone();
                    obstacle.traverse((node) => {
                        if (node.isMesh) {
                            const originalMaterial = node.material;
                            const obstacleMaterial = originalMaterial.clone();
                            // Vary colors: red, orange, purple, green, yellow
                            const colors = [0xff0000, 0xff6600, 0x9900ff, 0x00ff00, 0xffff00];
                            obstacleMaterial.color.setHex(colors[i % colors.length]);
                            obstacleMaterial.metalness = 0.9;
                            obstacleMaterial.roughness = 0.2;
                            node.material = obstacleMaterial;
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    // Spawn obstacles at different distances and lanes
                    const lanes = [-roadWidth / 3, 0, roadWidth / 3];
                    obstacle.position.set(
                        lanes[Math.floor(Math.random() * lanes.length)],
                        carBaseY,
                        roadLength * 0.3 + i * (roadLength * 0.15)
                    );
                    obstacle.rotation.y = Math.PI;
                    obstacle.userData.isObstacle = true;
                    obstacles.push(obstacle);
                    scene.add(obstacle);
                }
                console.log(`${numObstacles} additional obstacles created`);

                // Set initial Camera position AFTER carModel is loaded and carBaseY is known
                camera.position.set(0, carBaseY + 3, -7);
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);

            }, undefined, (error) => {
                // Fallback for car model loading failure
                console.error('An error happened loading the car model:', error);
                const fallbackGeo = new THREE.BoxGeometry(2, 1, 4);
                const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.5 });
                carModel = new THREE.Mesh(fallbackGeo, fallbackMat);
                carBaseY = 0.5 + 0.01; // Default for fallback box
                carModel.position.set(0, carBaseY, 0);
                carModel.castShadow = true;
                carModel.receiveShadow = true;
                scene.add(carModel);

                // Fallback enemy car
                enemyCar = new THREE.Mesh(fallbackGeo, new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5, metalness: 0.5 }));
                enemyCar.position.set(roadWidth / 4, carBaseY, roadLength * 0.7);
                enemyCar.castShadow = true;
                enemyCar.receiveShadow = true;
                scene.add(enemyCar);

                camera.position.set(0, carBaseY + 3, -7);
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
                loadingScreen.textContent = 'Error loading car model. Displaying fallback.';
                loadingScreen.classList.remove('hidden');
                loadingScreen.style.opacity = 1;
            });

            // --- Restart Button Listener ---
            restartButton.addEventListener('click', restartGame);

            // --- Resize Listener ---
            window.addEventListener('resize', onWindowResize, false);
            // --- Initial Score Display ---
            updateScoreDisplay();
        }

        // --- ABSOLUTE FINAL FAIL-SAFE BUTTON LOGIC ---
        function setupControls() {
            // Desktop keyboard compatibility - ROBUST VELOCITY SYSTEM
            window.addEventListener('keydown', (event) => {
                if (isGameOver) return;
                if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') { 
                    carVelocityX = -CAR_SPEED; // Use constant speed left
                    leftControlButton.classList.add('pressed');
                }
                else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') { 
                    carVelocityX = CAR_SPEED; // Use constant speed right
                    rightControlButton.classList.add('pressed');
                }
            });
            
            window.addEventListener('keyup', (event) => {
                if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') { 
                    carVelocityX = 0; // Stop movement
                    leftControlButton.classList.remove('pressed');
                }
                else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') { 
                    carVelocityX = 0; // Stop movement
                    rightControlButton.classList.remove('pressed');
                }
            });

            // ABSOLUTE FINAL: Left Control with Maximum Override
            if (leftControlButton) {
                leftControlButton.addEventListener('pointerdown', (e) => {
                    if (isGameOver) return;
                    
                    // MANDATORY webview overrides
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // ROBUST VELOCITY SYSTEM: Set constant speed left
                    carVelocityX = -CAR_SPEED;
                    
                    // Visual feedback
                    leftControlButton.classList.add('pressed');
                    
                }, { passive: false }); // MANDATORY for webview
                
                leftControlButton.addEventListener('pointerup', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // VELOCITY MODEL: Stop movement
                    carVelocityX = 0;
                    leftControlButton.classList.remove('pressed');
                    
                }, { passive: false });
                
                leftControlButton.addEventListener('pointercancel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // VELOCITY MODEL: Stop movement
                    carVelocityX = 0;
                    leftControlButton.classList.remove('pressed');
                    
                }, { passive: false });
            }

            // ABSOLUTE FINAL: Right Control with Maximum Override
            if (rightControlButton) {
                rightControlButton.addEventListener('pointerdown', (e) => {
                    if (isGameOver) return;
                    
                    // MANDATORY webview overrides
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // ROBUST VELOCITY SYSTEM: Set constant speed right
                    carVelocityX = CAR_SPEED;
                    
                    // Visual feedback
                    rightControlButton.classList.add('pressed');
                    
                }, { passive: false }); // MANDATORY for webview
                
                rightControlButton.addEventListener('pointerup', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // VELOCITY MODEL: Stop movement
                    carVelocityX = 0;
                    rightControlButton.classList.remove('pressed');
                    
                }, { passive: false });
                
                rightControlButton.addEventListener('pointercancel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // VELOCITY MODEL: Stop movement
                    carVelocityX = 0;
                    rightControlButton.classList.remove('pressed');
                    
                }, { passive: false });
            }
            
            // Restart functionality
            if (restartMessage) {
                restartMessage.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    restartGame();
                }, { passive: false });
                
                restartMessage.addEventListener('click', restartGame);
            }
            
        }
        // --- End Setup Controls ---

        function resetPointPosition(point, initial = false) {
            const laneWidth = roadWidth / 2 - kerbWidth - pointRadius * 2;
            point.position.x = (Math.random() * 2 - 1) * laneWidth;
            point.position.y = pointRadius + 0.01;
            if (initial) {
                point.position.z = Math.random() * roadLength * 0.8 - roadLength * 0.4; // Initial spread within visible range
            } else {
                point.position.z = roadLength / 2 + Math.random() * roadLength * 0.5; // Spawn well ahead
            }
            point.visible = true;
        }

        function updateScoreDisplay() { 
            scoreElement.textContent = score.toString();
        }
        
        function updateTimerDisplay() {
            const minutes = Math.floor(countdownTime / 60);
            const seconds = Math.floor(countdownTime % 60);
            const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            timerElement.textContent = formattedTime;
            
            // Add warning style when time is low (last 10 seconds)
            if (countdownTime <= 10 && countdownTime > 0) {
                timerElement.classList.add('warning');
            } else {
                timerElement.classList.remove('warning');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(currentTime) {
            requestAnimationFrame(animate); // IMPORTANT: This creates the continuous game loop

            // ROBUST VELOCITY-BASED SYSTEM: Direct position update (Space Invaders model)
            if (carModel && !isGameOver) {
                // Apply velocity directly - no interpolation, no complex logic
                carModel.position.x += carVelocityX;
                
                // Clamp to road bounds to prevent car from going off the road
                const maxBounds = (roadWidth / 2) - kerbWidth - 1;
                carModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, carModel.position.x));
                
                // Update camera to follow car smoothly
                if (camera) {
                    const targetCameraX = carModel.position.x * 0.3;
                    camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                }
            }

            // Game state checks
            if (isGameOver || !gameStarted) {
                renderer.render(scene, camera);
                return; // Stop game logic but continue rendering
            }

            // --- Calculate Delta Time ---
            if (lastFrameTime === 0) {
                lastFrameTime = currentTime;
                return; // Skip first frame to establish baseline
            }
            
            const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
            lastFrameTime = currentTime;
            
            // Accumulate time for countdown timer
            accumulatedTime += deltaTime;

            // --- Countdown Timer ---
            // Update every time we accumulate 1 second
            while (accumulatedTime >= 1.0) {
                countdownTime -= 1; // Decrement by 1 second
                accumulatedTime -= 1.0; // Reduce accumulator by 1 second
                updateTimerDisplay();
                console.log("Timer tick:", countdownTime); // Debug log
                
                // Check if time ran out
                if (countdownTime <= 0) {
                    countdownTime = 0;
                    updateTimerDisplay();
                    console.log("Time's up!");
                    triggerGameOver();
                    return;
                }
            }

            // --- Progressive Difficulty: Increase Speed Over Time ---
            gameTime += deltaTime;
            if (gameTime - lastSpeedIncrease >= speedIncreaseInterval) {
                driveSpeed = Math.min(driveSpeed + speedIncreaseAmount, baseDriveSpeed * 2); // Cap at 2x base speed
                lastSpeedIncrease = gameTime;
                console.log(`Speed increased to ${driveSpeed.toFixed(2)}`);
            }

            const deltaZ = driveSpeed;

            // --- Scenery Movement and Recycling ---
            roadLines.forEach(line => {
                line.position.z -= deltaZ;
                if (line.position.z < -sceneryRecycleDistance) {
                    line.position.z += roadLength * 1.5; // Loop the lines
                }
            });

            buildings.forEach(building => {
                building.position.z -= deltaZ;
                if (building.position.z < -sceneryRecycleDistance - building.geometry.parameters.depth / 2) {
                    const sideSign = Math.sign(building.position.x);
                    const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2;
                    building.position.set(sideSign * xOffset, building.geometry.parameters.height / 2, roadLength * 1.5 / 2 + Math.random() * buildingSpacing * 2);
                }
            });

            streetLights.forEach(light => {
                light.position.z -= deltaZ;
                if (light.position.z < -sceneryRecycleDistance) {
                    const sideSign = Math.sign(light.position.x);
                    const xPos = roadWidth / 2 + kerbWidth + 0.8;
                    light.position.set(sideSign * xPos, 0, roadLength * 1.5 / 2 + Math.random() * lightSpacing * 2);
                }
            });

            trafficLights.forEach(light => {
                light.position.z -= deltaZ;
                if (light.position.z < -sceneryRecycleDistance) {
                    const sideSign = Math.sign(light.position.x);
                    const xPos = roadWidth / 2 + kerbWidth + 0.5;
                    light.position.set(sideSign * xPos, 0, roadLength * 1.5 / 2 + Math.random() * roadLength * 0.5); // Spawn further out
                }
            });

            kerbs.forEach(kerb => {
                kerb.position.z -= deltaZ;
                if (kerb.position.z < -sceneryRecycleDistance) {
                    kerb.position.z += roadLength * 1.5;
                }
            });


            // --- Move and Recycle Points ---
            points.forEach(point => {
                if (!point.visible) return; // Only move visible points
                point.position.z -= deltaZ;
                point.rotation.y += 0.05; // Coin rotation
                if (point.position.z < -sceneryRecycleDistance) {
                    resetPointPosition(point);
                }
            });

            // --- Move Enemy Car ---
            if (enemyCar && carModel) { // Ensure both are loaded
                // Enemy car moves forward relative to world, while road scrolls towards player.
                // This creates the illusion of the enemy coming towards the player.
                enemyCar.position.z -= (enemyCarSpeed + driveSpeed); // Sum of own speed and road scroll speed

                if (enemyCar.position.z < -sceneryRecycleDistance) { // Recycle when it passes player
                    enemyCar.position.z = roadLength * 0.5 + Math.random() * roadLength * 0.3; // Spawn closer for more challenge
                    // Smart lane selection: sometimes block two lanes to force player movement
                    const lanes = [-roadWidth / 3, 0, roadWidth / 3];
                    enemyCar.position.x = lanes[Math.floor(Math.random() * lanes.length)];
                    enemyCar.rotation.y = Math.PI; // Ensure it's facing forward
                }
            }

            // --- Move Additional Obstacles ---
            obstacles.forEach((obstacle, index) => {
                obstacle.position.z -= (enemyCarSpeed * 0.8 + driveSpeed); // Slightly slower than main enemy
                
                if (obstacle.position.z < -sceneryRecycleDistance) {
                    // Spawn obstacles with strategic positioning to force lane changes
                    const lanes = [-roadWidth / 3, 0, roadWidth / 3];
                    const spawnDistance = roadLength * 0.4 + Math.random() * roadLength * 0.4;
                    
                    // 40% chance to spawn adjacent obstacles (blocking 2 lanes)
                    if (Math.random() < 0.4 && obstacles.length > 1) {
                        const otherObstacle = obstacles[(index + 1) % obstacles.length];
                        // Check if other obstacle is nearby
                        if (Math.abs(otherObstacle.position.z - spawnDistance) < roadLength * 0.2) {
                            // Place this obstacle adjacent to the other one
                            const otherLaneIndex = lanes.indexOf(Math.round(otherObstacle.position.x / (roadWidth / 3)) * (roadWidth / 3));
                            if (otherLaneIndex !== -1 && otherLaneIndex < lanes.length - 1) {
                                obstacle.position.x = lanes[otherLaneIndex + 1];
                            } else {
                                obstacle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
                            }
                        } else {
                            obstacle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
                        }
                    } else {
                        obstacle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
                    }
                    
                    obstacle.position.z = spawnDistance;
                    obstacle.rotation.y = Math.PI;
                }
            });


            // --- Update Player Bounding Box (movement handled at top of loop) ---
            if (carModel) {
                playerBox.setFromObject(carModel); // Always update player's bounding box
            }

            // --- Update Camera (smooth follow) ---
            if (carModel) {
                const targetCameraX = carModel.position.x * 0.5; // Camera follows less drastically than car
                camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
            }


            // --- Collision Detection ---
            if (carModel) {
                // Point Collision
                points.forEach(point => {
                    if (!point.visible) return;
                    pointBox.setFromObject(point);
                    if (playerBox.intersectsBox(pointBox)) {
                        score += pointValue;
                        updateScoreDisplay();
                        point.visible = false; // Make point disappear
                    }
                });

                // Enemy Collision - FIXED: Tightened hitboxes to prevent false collisions
                if (enemyCar && enemyCar.parent) { // Ensure enemyCar is in scene
                    enemyBox.setFromObject(enemyCar);
                    
                    // Shrink hitboxes for more accurate collision detection
                    // Only trigger collision when cars are actually touching
                    const shrunkPlayerBox = playerBox.clone().expandByScalar(-0.3); // Shrink by 0.3 units
                    const shrunkEnemyBox = enemyBox.clone().expandByScalar(-0.3); // Shrink by 0.3 units
                    
                    if (shrunkPlayerBox.intersectsBox(shrunkEnemyBox)) {
                        console.log("Collision with enemy! Player pos:", carModel.position.x.toFixed(2), "Enemy pos:", enemyCar.position.x.toFixed(2));
                        triggerGameOver();
                    }
                }

                // Additional Obstacles Collision - FIXED: Tightened hitboxes
                obstacles.forEach(obstacle => {
                    if (obstacle && obstacle.parent) {
                        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                        
                        // Shrink hitboxes for accurate collision detection
                        const shrunkPlayerBox = playerBox.clone().expandByScalar(-0.3); // Shrink by 0.3 units
                        const shrunkObstacleBox = obstacleBox.clone().expandByScalar(-0.3); // Shrink by 0.3 units
                        
                        if (shrunkPlayerBox.intersectsBox(shrunkObstacleBox)) {
                            console.log("Collision with obstacle! Player pos:", carModel.position.x.toFixed(2), "Obstacle pos:", obstacle.position.x.toFixed(2));
                            triggerGameOver();
                        }
                    }
                });
            }

            // --- Render ---
            renderer.render(scene, camera);
        }

        // --- Game Over Handler ---
        function triggerGameOver() {
            if (isGameOver) return; // Prevent multiple triggers
            
            isGameOver = true;
            
            // VELOCITY MODEL: Stop all movement
            carVelocityX = 0;
            
            // Hide control container
            controlContainer.classList.add('hidden');
            
            // Show blur overlay
            document.getElementById('game-over-blur').style.display = 'block';
            
            // Show custom message
            document.getElementById('game-over-message').style.display = 'block';
            document.getElementById('restart-message').style.display = 'block';
            
            // Report final score to parent (PROTECTED CODE)
            window.parent.postMessage({ type: "GAME_OVER", score: score }, "*");
            console.log("Game Over! Final Score:", score);
        }

        function restartGame() {
            // Reset game state
            isGameOver = false;
            score = 0;
            gameTime = 0;
            lastSpeedIncrease = 0;
            driveSpeed = baseDriveSpeed; // Reset to base speed
            countdownTime = 60; // Reset timer to 60 seconds
            lastFrameTime = 0;
            accumulatedTime = 0;
            updateScoreDisplay();
            updateTimerDisplay();
            
            // Hide new game over UI
            document.getElementById('game-over-blur').style.display = 'none';
            document.getElementById('game-over-message').style.display = 'none';
            document.getElementById('restart-message').style.display = 'none';
            
            // VELOCITY MODEL: Reset movement and show controls
            carVelocityX = 0; // Ensure velocity is completely reset
            
            // Show control container
            controlContainer.classList.remove('hidden');
            
            gameOverElement.style.display = 'none';

            // Reset player car position
            if (carModel) {
                carModel.position.set(0, carBaseY, 0);
            }

            // Reset enemy car position
            if (enemyCar) {
                const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7);
            }

            // Reset obstacles
            obstacles.forEach((obstacle, i) => {
                const lanes = [-roadWidth / 3, 0, roadWidth / 3];
                obstacle.position.set(
                    lanes[Math.floor(Math.random() * lanes.length)],
                    carBaseY,
                    roadLength * 0.3 + i * (roadLength * 0.15)
                );
                obstacle.rotation.y = Math.PI;
            });

            // Reset points
            points.forEach(point => resetPointPosition(point, true));

            // Reset scenery positions (optional, they will naturally loop back)
            // Re-initializing positions for a "fresh" start visual.
            roadLines.forEach((line, i) => { line.position.z = (roadLength * 1.5 / 2) - (line.geometry.parameters.height / 2) - i * (line.geometry.parameters.height + 4); });
            buildings.forEach((building, i) => {
                const zPos = (roadLength * 1.5 / 2) - (buildingSpacing / 2) - (i % (numBuildings / 2)) * buildingSpacing; // Recalculate based on original distribution
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2;
                building.position.set(sideSign * xOffset, building.geometry.parameters.height / 2, zPos);
            });
            streetLights.forEach((light, i) => {
                const zPos = (roadLength * 1.5 / 2) - (lightSpacing / 2) - (i % (numLights / 2)) * lightSpacing;
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xPos = roadWidth / 2 + kerbWidth + 0.8;
                light.position.set(sideSign * xPos, 0, zPos);
            });
            trafficLights.forEach((light, i) => {
                const zPos = roadLength * 0.4; // Fixed traffic light
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xPos = roadWidth / 2 + kerbWidth + 0.5;
                light.position.set(sideSign * xPos, 0, zPos);
            });


            // The animate loop is continuously running, so no need to call it again.
            // Just setting isGameOver to false will resume game logic.
        }

    </script>
</body>

</html>